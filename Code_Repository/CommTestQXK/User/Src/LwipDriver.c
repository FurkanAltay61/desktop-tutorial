/*.$file${.::Src::LwipDriver.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: LwipDriver.qm
* File:  ${.::Src::LwipDriver.c}
*
* This code has been generated by QM 5.1.1 <www.state-machine.com/qm/>.
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This program is open source software: you can redistribute it and/or
* modify it under the terms of the GNU General Public License as published
* by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
* for more details.
*/
/*.$endhead${.::Src::LwipDriver.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

#include "CommDriver.h"


#define OS_TICKS_PER_SEC 2
#define UDP_SERVER_PORT    8   /* define the UDP local connection port */
#define UDP_CLIENT_PORT    7   /* define the UDP remote connection port */

#define LOCALIP_1 192
#define LOCALIP_2 168
#define LOCALIP_3 0
#define LOCALIP_4 10

#define REMOTEIP_1 192
#define REMOTEIP_2 168
#define REMOTEIP_3 0
#define REMOTEIP_4 1


struct pbuf *pbuf_new(u8_t *data, u16_t len);
void udp_rx_callback(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16_t port);

/*.$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*. Check for the minimum required QP version */
#if (QP_VERSION < 690U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.9.0 or higher required
#endif
/*.$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*.$define${AOs::LwipDriver} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*.${AOs::LwipDriver} ......................................................*/
/*.${AOs::LwipDriver::ctor} ................................................*/
void LwipDriver_ctor(LwipDriver * const me) {
	MX_LWIP_Init();
    QActive_ctor(&me->super, (QStateHandler)&LwipDriver_initial);
    QTimeEvt_ctorX(&me->te,&me->super,LWIP_PROCESS_SIG,0U);
}

/*.${AOs::LwipDriver::SM} ..................................................*/
QState LwipDriver_initial(LwipDriver * const me, void const * const par) {
    /*.${AOs::LwipDriver::SM::initial} */
    err_t PosErr=0;
    me->upcb = udp_new();
    IP4_ADDR(&me->upcb->remote_ip,REMOTEIP_1,REMOTEIP_2,REMOTEIP_3,REMOTEIP_4);
    me->upcb->remote_port = UDP_SERVER_PORT;
    IP4_ADDR(&me->upcb->local_ip,LOCALIP_1,LOCALIP_2,LOCALIP_3,LOCALIP_4);
    me->upcb->local_port = UDP_CLIENT_PORT;
    PosErr = udp_bind(me->upcb, &me->upcb->local_ip,me->upcb->local_port);
    if(PosErr == 0){
      udp_recv(me->upcb, &udp_rx_callback, NULL);
    }

    QActive_subscribe((QActive *)me, LWIP_TX_SIG);

    return Q_TRAN(&LwipDriver_LwipMngr);
}
/*.${AOs::LwipDriver::SM::LwipMngr} ........................................*/
QState LwipDriver_LwipMngr(LwipDriver * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*.${AOs::LwipDriver::SM::LwipMngr} */
        case Q_ENTRY_SIG: {
            QTimeEvt_armX(&me->te, OS_TICKS_PER_SEC/2, OS_TICKS_PER_SEC/2);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::LwipDriver::SM::LwipMngr} */
        case Q_EXIT_SIG: {
            QTimeEvt_disarm(&me->te);
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::LwipDriver::SM::LwipMngr::LWIP_PROCESS} */
        case LWIP_PROCESS_SIG: {
            //MX_LWIP_Process();
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::LwipDriver::SM::LwipMngr::LWIP_RX} */
        case LWIP_RX_SIG: {
            char temptext[20];
            strncpy(temptext, ((TextEvt const *)e)->text,Q_DIM(temptext));
            status_ = Q_HANDLED();
            break;
        }
        /*.${AOs::LwipDriver::SM::LwipMngr::LWIP_TX} */
        case LWIP_TX_SIG: {
            struct pbuf *p = pbuf_new((u8_t *)((TextEvt const *)e)->text,
                                  strlen(((TextEvt const *)e)->text) + 1);
            if (p != (struct pbuf *)0) {
                udp_send(me->upcb, p);
                pbuf_free(p);                   /* don't leak the pbuf! */
            }
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*.$enddef${AOs::LwipDriver} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/


/**
  * @brief This function is called when an UDP datagrm has been received on the port UDP_PORT.
  * @param arg user supplied argument (udp_pcb.recv_arg)
  * @param pcb the udp_pcb which received data
  * @param p the packet buffer that was received
  * @param addr the remote IP address from which the packet was received
  * @param port the remote port from which the packet was received
  * @retval None
  */
void udp_rx_callback(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
{
  //QActive const *AO_LwipDriver;
//  TextEvt *te = Q_NEW(TextEvt, LWIP_TX_SIG);
//  snprintf(te->text,MAX_TEXT_LEN,(char *)p->payload);
//  QF_PUBLISH((QEvt *)te, AO_LwipDriver);
//  TextEvt *re = Q_NEW(TextEvt, UART_TX_SIG);
//  snprintf(re->text,MAX_TEXT_LEN,(char *)p->payload);
//  QF_PUBLISH((QEvt *)re, AO_LwipDriver);
  pbuf_free(p); /* don't leak the pbuf! */

}


/**
  * @brief  EXTI line detection callbacks.
  * @param  GPIO_Pin Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  /* Prevent unused argument(s) compilation warning */
  //QActive * const AO_LwipDriver;
  UNUSED(GPIO_Pin);
  //TextEvt *te = Q_NEW(TextEvt, LWIP_TX_SIG);
  //strcpy(te->text, "Butona Basildi\n");
  //QACTIVE_POST(AO_LwipDriver, (QEvt *)te, 0U);
}

/* utilities added by QL ...................................................*/
/**
* Allocate a transport-layer pbuf and copies the provided data buffer 'data'
* of length 'len' bytes into the payload(s) of the pbuf. The function takes
* care of splitting the data into successive pbuf payloads, if necessary.
*
* The function returns the newly created pbuf or NULL if the pbuf cannot
* be allocated.
*/
struct pbuf *pbuf_new(u8_t *data, u16_t len) {
    struct pbuf *p = pbuf_alloc(PBUF_TRANSPORT, len, PBUF_RAM);
    struct pbuf *q = p;
    while ((q != (struct pbuf *)0) && (len >= q->len)) {
        memcpy(q->payload, data, q->len);         /* copy data into payload */
        len  -= q->len;                                 /* remaining length */
        data += q->len;                              /* remainig data chunk */
        q = q->next;                                       /* get next pbuf */
    }
    return p;
}


